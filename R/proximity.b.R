proximityClass <- if (requireNamespace("jmvcore")) R6::R6Class(
    "proximityClass",
    inherit = proximityBase,
    private = list(
        # ====================================================
        .init = function() {
            mtxSbj = self$results$mtxSbj$setVisible(FALSE)
            mtxVar = self$results$mtxVar$setVisible(FALSE)
        },
        # ====================================================
        .run = function() {
            # get variables
            pxmVar = self$options$get("vars")

            if (length(pxmVar) > 1) {
                # get variables
                pxmLbl = self$options$get("label")
                mtxSbj = self$results$get("mtxSbj")
                mtxVar = self$results$get("mtxVar")
                lvlBin = (self$options$get("lvlMsr") == "lvlBin")
                lvlCnt = (self$options$get("lvlMsr") == "lvlCnt")
                lvlInt = (self$options$get("lvlMsr") == "lvlInt")
                btwSbj = (self$options$get("btwDir") == "btwSbj")
                btwVar = (self$options$get("btwDir") == "btwVar")
                binAbs = as.numeric(self$options$get("binAbs"))
                binPrs = as.numeric(self$options$get("binPrs"))

                numSbj = dim(self$data)[1]
                dtaMtx = self$data[, pxmVar]
                sbjLbl = as.list(sprintf(paste0("C %", sprintf("%d", ceiling(log10(numSbj))), "d"), seq(1:numSbj)))
                if (length(pxmLbl) == 1) {
                    rawLbl = self$data[, pxmLbl]
                    if (length(levels(rawLbl)) == numSbj)
                        sbjLbl = as.list(as.character(rawLbl))
                }
                blnVld = !apply(is.na(dtaMtx), 1, any)
                dtaMtx = dtaMtx[blnVld, ]
                sbjLbl = sbjLbl[blnVld]
                numIvN = length(blnVld[!blnVld])
                # for binary data, ensure that these only contain the two categories defined by binAbs and binPrs
                numIvB = 0
                if (lvlBin) {
                    blnAbs = (dtaMtx == as.numeric(self$options$get("binAbs")))
                    blnPrs = (dtaMtx == as.numeric(self$options$get("binPrs")))
                    blnBnC = apply(blnAbs | blnPrs, 1, all)
                    dtaMtx = dtaMtx[blnBnC, ]
                    sbjLbl = sbjLbl[blnBnC]
                    blnAbs = blnAbs[blnBnC, ]
                    blnPrs = blnPrs[blnBnC, ]
                    numIvB = length(blnBnC[!blnBnC])
                    # replace absent with 0 and present with 1
                    dtaMtx(blnAbs) = 0
                    dtaMtx(blnPrs) = 1
                }
                clcDis = (self$options$get("disSim") == "clcDis")
                clcSim = (self$options$get("disSim") == "clcSim")
                lvlNme = ifelse(lvlInt, "int", ifelse(lvlCnt, "cnt", ifelse(lvlBin, "bin", "")))
                mthNme = paste0(lvlNme, substr(self$options$get(paste0(lvlNme, ifelse(clcDis, "Dis", ifelse(clcSim, "Sim", "")))), 4, 6))
                mthExp = c(self$options$get("intPwr"), self$options$get("intRot"))

                # include R-file with the algorithms
# doesn't work
                # transform data (if necessary)
                # The Transform Values group allows you to standardize data values for either cases or variables before computing proximities.
                # These transformations are not applicable to binary data. Available standardization methods are z scores, range –1 to 1,
                # range 0 to 1, maximum magnitude of 1, mean of 1, and standard deviation of 1.
                if (self$options$get("xfmMth") != "xfmNon")
                    dtaMtx = xfmDta(dtaMtx, self$options$get("xfmMth"), self$options$get("xfmDir"))
                # transpose the matrix if similarities between subject are to be calculated
                if (btwSbj)
                    dtaMtx = t(dtaMtx)

                # calculate proximity measures
                # mthExp is only required for Minkowski and Custom within integer dissimilarities
                resMtx = algPxm(dtaMtx, mthNme, mthExp)

                # The Transform Measures group allows you to transform the values generated by the distance measure. They are applied after
                # the distance measure has been computed. Available options are absolute values, change sign, and rescale to 0–1 range.
                blnXfR = c(self$options$get("xfmAbs"), self$options$get("xfmInv"), self$options$get("xfmRsc"))
                if (any(blnXfR))
                    resMtx = xfmRes(resMtx, blnXfR)

                # assign results
                if      (btwVar) {
                    # initialize the results table (add the required number of columns)
                    for (i in seq_along(pxmVar)) {
                        mtxVar$addColumn(name=pxmVar[[i]], title=pxmVar[[i]], type="number", format="zto")
                    }

                    # populate results
                    for (i in seq_along(pxmVar)) {
                        values <- list()
                        for (j in seq_along(pxmVar)) {
#                           values[[pxmVar[[j]]]]  = ifelse(i > j, resMtx[i, j], ifelse(i < j, "", "\u2014"))
                            values[[pxmVar[[j]]]]  = resMtx[i, j]
                        }
                        mtxVar$setRow(rowNo=i, values)
                    }

                    # initialize the results table (assign the notes underneath)
                    mtxVar$setNote("pxmInf", gsub("_BA_", sprintf('%d', binAbs), gsub("_BP_", sprintf('%d', binPrs), gsub("_IP_", sprintf('%d', mthExp[1]), gsub("_IR_", sprintf('%d', mthExp[2]),
                                                  paste0(ifelse(clcSim, "Similarities ", ifelse(clcDis, "Dissimilarities ", "ERROR")), " between variables; Method: ", nmePxm(mthNme), " (SPSS: ", spsPxm(mthNme), ")"))))))
                    mtxVar$setNote("numSbj", paste0("Total number of cases: ", sprintf("%d", numSbj), "; excluded because of invalid data (NA): ", sprintf("%d", numIvN), ifelse(lvlBin, paste0(" and of invalid categories: ", sprintf("%d", numIvB)), ""),
                                                    "; Included cases: ",    sprintf("%d", numSbj - numIvN - numIvB)))
                    # make the table visible
                    mtxVar$setVisible(TRUE)
                }
                else if (btwSbj) {
                    # initialize the results table (add the required number of columns)
                    for (i in seq_along(sbjLbl)) {
                        mtxSbj$addColumn(name=sbjLbl[[i]], title=sbjLbl[[i]], type="number", format="zto")
                    }

                    # populate results
                    for (i in seq_along(sbjLbl)) {
                        values <- list()
                        values[[".name"]] = sbjLbl[[i]]
                        for (j in seq_along(sbjLbl)) {
#                           values[[sbjLbl[[j]]]] = ifelse(i > j, resMtx[i, j], ifelse(i < j, "", "\u2014"))
                            values[[sbjLbl[[j]]]] = resMtx[i, j]
                        }

                        mtxSbj$addRow(rowKey=sbjLbl[[i]], values)
                    }

                    # initialize the results table (assign the notes underneath)
                    mtxSbj$setNote("pxmInf", gsub("_BA_", sprintf('%d', binAbs), gsub("_BP_", sprintf('%d', binPrs), gsub("_IP_", sprintf('%d', mthExp[1]), gsub("_IR_", sprintf('%d', mthExp[2]),
                                                  paste0(ifelse(clcSim, "Similarities ", ifelse(clcDis, "Dissimilarities ", "ERROR")), " between cases; Method: ", nmePxm(mthNme), " (SPSS: ", spsPxm(mthNme), ")"))))))
                    mtxSbj$setNote("numSbj", paste0("Total number of cases: ", sprintf("%d", numSbj), "; excluded because of invalid data (NA): ", sprintf("%d", numIvN), ifelse(lvlBin, paste0(" and of invalid categories: ", sprintf("%d", numIvB)), ""),
                                                    "; Included cases: ",    sprintf("%d", numSbj - numIvN - numIvB)))
                    # make the table visible
                    mtxSbj$setVisible(TRUE)
                }
            }
        }
    )
)

# =====================================================================================================================
# Algorithms to calculate proximities
# =====================================================================================================================
algPxm <- function(dtaMtx, mthNme, mthExp) {
    # =================================================================================================================
    # integer measures that implemented using R functions (cor, dist)
    # =================================================================================================================
    # integer - similarity - Pearson correlation - CORRELATION
    if      (mthNme == "intCrr") {
        resMtx = cor(dtaMtx)
    }
    # integer - dissimilarity - Euclidian distance, squared Euclidian distance, Chebychev, Block, Minkowski, Customized
    else if (mthNme == "intEuc" || mthNme == "intSqE" || mthNme == "intChb" || mthNme == "intBlk" || mthNme == "intMnk" || mthNme == "intCst") {
       # distance measures from the R-function dist
       dstMth = ifelse(mthNme == "intEuc" || mthNme == "intSqE", "euclidian", ifelse(mthNme == "intChb", "maximum", ifelse(mthNme == "intBlk", "manhattan", ifelse(mthNme == "intMnk" || mthNme == "intCst", "minkowski", "error"))))
       dstExp = ifelse(mthNme == "intSqE", 2, ifelse(mthNme == "intCst", (mthExp[1] / mthExp[2]), 1))
       resMtx = as.matrix(dist(t(dtaMtx), upper=T, diag=T, method=dstMth, p = mthExp[1]) ^ dstExp)
    }
    # =================================================================================================================
    # integer, count and binary measures; implemented based upon:
    # www.ibm.com/support/knowledgecenter/SSLVMB_22.0.0/com.ibm.spss.statistics.algorithms/alg_proximities.htm
    # see www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/binmatch.htm for further possible measures
    # =================================================================================================================
    else {
        # create result matrix
        resMtx = array(0, c(ncol(dtaMtx), ncol(dtaMtx)))
        dimnames(resMtx) = list(colnames(dtaMtx), colnames(dtaMtx))

        # preparation: binary measures
        if (mthNme == "binShp")
            dtaMtx = scale(dtaMtx, center=T, scale=F)

        # for most calculations, the main diagonal doesn't need to be calculated
        # however, there are three measures that represent an exception from that
        # those methods are the same where the main diagonal is divided by two at
        #  the very end of this algorithm
        if (mthNme == "binAnD" || mthNme == "binDsp" || mthNme == "binRnR")
            minI = 1
        else
            minI = 2

        for (i in minI:ncol(dtaMtx)) {
            for (j in 1:(i - minI + 1)) {
                # =====================================================================================================
                # calculate match vector and t1 / t2 required for binary measures
                # =====================================================================================================
                if (mthNme == "binAnD" || mthNme == "binDsp" || mthNme == "binKc2" || mthNme == "binLmb" || mthNme == "binOch" || mthNme == "binPh4" || mthNme == "binPtD" || 
                    mthNme == "binSk4" || mthNme == "binSk5" || mthNme == "binSzD" || mthNme == "binVar" || mthNme == "binYlQ" || mthNme == "binYlY") {
                    mtcVec = c(as.vector(table(dtaMtx[, i] == 1 & dtaMtx[, j] == 1)["TRUE"]), as.vector(table(dtaMtx[, i] == 1 & dtaMtx[, j] != 1)["TRUE"]), as.vector(table(dtaMtx[, i] != 1 & dtaMtx[, j] == 1)["TRUE"]), as.vector(table(dtaMtx[, i] != 1 & dtaMtx[, j] != 1)["TRUE"]))
                    if (mthNme == "binAnD" || mthNme == "binLmb") {
                        t1 = max(mtcVec[1], mtcVec[2], na.rm=T) + max(mtcVec[3], mtcVec[4], na.rm=T) + max(mtcVec[1], mtcVec[3], na.rm=T) + max(mtcVec[2], mtcVec[4], na.rm=T)
                        t2 = max(sum(mtcVec[1], mtcVec[3], na.rm=T), sum(mtcVec[2], mtcVec[4], na.rm=T), na.rm=T) + max(sum(mtcVec[1], mtcVec[2], na.rm=T), sum(mtcVec[3], mtcVec[4], na.rm=T), na.rm=T)
                    }
                }

                # =====================================================================================================
                # measures for integer data
                # =====================================================================================================
                # integer - similarity - Cosine - COSINE
                if      (mthNme == "intCos") {
                    resMtx[i, j] = crossprod(dtaMtx[, i], dtaMtx[, j]) / sqrt(crossprod(dtaMtx[, i]) * crossprod(dtaMtx[, j]))
                }
#               PLACEHOLDER FOR FUTURE IMPLEMENTATIONS
#               else if (mthNme == "int") {
#               }    
                # =====================================================================================================
                # measures for count data
                # =====================================================================================================
                # dissimilarities - counts - Chi-square measure: disChi - CHISQ
                else if (mthNme == "cntChi") {
                    resMtx[i, j] = NA # to implement
                }
                # dissimilarities - counts - Phi-square measure: disPhi - PH2
                else if (mthNme == "cntPhi") {
                    resMtx[i, j] = NA # to implement
                }
#               PLACEHOLDER FOR FUTURE IMPLEMENTATIONS
#               else if (mthNme == "cnt") {
#               }
                # =====================================================================================================
                # measures for binary data
                # =====================================================================================================
                # binary - similarity - Anderberg's D: binAnD - D
                else if (mthNme == "binAnD") {
                    resMtx[i, j] = (t1 - t2) / (2 * nrow(dtaMtx))
                }
                # binary - similarity - Dice: binDic - DICE
                else if (mthNme == "binDic") {
                    resMtx[i, j] = (as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]) * 2) / (as.vector(table(dtaMtx[, i] | dtaMtx[, j])["TRUE"]) + as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]))
                }
                # binary - similarity - Dispersion: binDsp - DISPER
                else if (mthNme == "binDsp") {
                    resMtx[i, j] = ((mtcVec[1] * mtcVec[4]) - ifelse(is.na(mtcVec[2]) || is.na(mtcVec[3]), 0, (mtcVec[2] * mtcVec[3]))) / (nrow(dtaMtx) ^ 2)
                }
                # binary - dissimilarity - Euclidian distance: binEuc - BEUCLID
                else if (mthNme == "binEuc") {
                    resMtx[i, j] = sqrt(as.vector(table(dtaMtx[, i] != dtaMtx[, j])["TRUE"]))
                }
                # binary - similarity - Jaccard: binJcc - JACCARD
                else if (mthNme == "binJcc") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]) / as.vector(table(dtaMtx[, i] | dtaMtx[, j])["TRUE"])
                }
                # binary - similarity - Hamann: binHmn - HAMANN
                else if (mthNme == "binHmm") {
                    resMtx[i, j] = (as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"]) - as.vector(table(dtaMtx[, i] != dtaMtx[, j])["TRUE"])) / nrow(dtaMtx)
                }
                # binary - similarity - Kulczynski 1: binKc1 - K1
                else if (mthNme == "binLmb") {
                    resMtx[i, j] = (t1 - t2) / (2 * nrow(dtaMtx) - t2)
                }
                # binary - similarity - Kulczynski 2: binKc2 - K2
                else if (mthNme == "binKc1") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]) / (as.vector(table(dtaMtx[, i] | dtaMtx[, j])["TRUE"]) - as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]))
                }
                # binary - similarity - Lambda: binLmb - LAMBDA
                else if (mthNme == "binKc2") {
                    resMtx[i, j] = (mtcVec[1] / (mtcVec[1] + mtcVec[2]) + mtcVec[1] / (mtcVec[1] + mtcVec[3])) / 2
                }
                # binary - dissimilarity - Lance and Williams: binLnW - BLWMN
                else if (mthNme == "binLnW") {
                    resMtx[i, j] = sum(abs(dtaMtx[, i] - dtaMtx[, j])) / sum(dtaMtx[, i] + dtaMtx[, j])
                }
                # binary - similarity - Ochiai: binOch - OCHIAI
                else if (mthNme == "binOch") {
                    resMtx[i, j] = sqrt((mtcVec[1] / (mtcVec[1] + mtcVec[2])) * (mtcVec[1] / (mtcVec[1] + mtcVec[3])))
                }
                # binary - similarity - Phi 4-point correlation: binPh4 - PHI
                else if (mthNme == "binPh4") {
                    resMtx[i, j] = ((mtcVec[1] * mtcVec[4]) - (mtcVec[2] * mtcVec[3])) / sqrt((mtcVec[1] + mtcVec[2]) * (mtcVec[1] + mtcVec[3]) * (mtcVec[2] + mtcVec[4]) * (mtcVec[3] + mtcVec[4]))
                }
                # binary - dissimilarity - Pattern difference: binPtD - PATTERN
                else if (mthNme == "binPtD") {
                    resMtx[i, j] = (mtcVec[2] * mtcVec[3]) / (nrow(dtaMtx) ^ 2)
                }
                # binary - similarity - Russel and Rao: binRnR - RR
                else if (mthNme == "binRnR") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]) / nrow(dtaMtx)
                }
                # binary - similarity - Rogers and Tanimoto: binRnT - RT
                else if (mthNme == "binRnT") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"]) / (as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"]) + 2 * as.vector(table(dtaMtx[, i] == dtaMtx[, j])["FALSE"]))
                }
                # binary - dissimilarity - Shape: binShp - BSHAPE
                else if (mthNme == "binShp") {
                    resMtx[i, j] = sum((dtaMtx[, i] - dtaMtx[, j]) ^ 2) / nrow(dtaMtx)
                }
                # binary - similarity - Sokal and Sneath 1: binSk1 - SS1
                else if (mthNme == "binSk1") {
                    resMtx[i, j] = (2 * as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"])) / (2 * as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"]) + as.vector(table(dtaMtx[, i] == dtaMtx[, j])["FALSE"]))
                }
                # binary - similarity - Sokal and Sneath 2: binSk2 - SS2
                else if (mthNme == "binSk2") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]) / (2 * as.vector(table(dtaMtx[, i] | dtaMtx[, j])["TRUE"]) - as.vector(table(dtaMtx[, i] & dtaMtx[, j])["TRUE"]))
                }
                # binary - similarity - Sokal and Sneath 3: binSk3 - SS3
                else if (mthNme == "binSk3") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"]) / as.vector(table(dtaMtx[, i] == dtaMtx[, j])["FALSE"])
                }
                # binary - similarity - Sokal and Sneath 4: binSk4 - SS4
                else if (mthNme == "binSk4") {
                    resMtx[i, j] = (mtcVec[1] / (mtcVec[1] + mtcVec[2]) + mtcVec[1] / (mtcVec[1] + mtcVec[3]) + mtcVec[4] / (mtcVec[2] + mtcVec[4]) + mtcVec[4] / (mtcVec[3] + mtcVec[4])) / 4
                }
                # binary - similarity - Sokal and Sneath 5: binSk5 - SS5
                else if (mthNme == "binSk5") {
                    resMtx[i, j] = (mtcVec[1] * mtcVec[4]) / sqrt((mtcVec[1] + mtcVec[2]) * (mtcVec[1] + mtcVec[3]) * (mtcVec[2] + mtcVec[4]) * (mtcVec[3] + mtcVec[4]))
                }
                # binary - similarity - Simple matching: binSmM - SM
                else if (mthNme == "binSmM") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] == dtaMtx[, j])["TRUE"]) / nrow(dtaMtx)
                }
                # binary - dissimilarity - Squared Euclidian distance: binSqE - BSEUCLID
                else if (mthNme == "binSqE") {
                    resMtx[i, j] = as.vector(table(dtaMtx[, i] != dtaMtx[, j])["TRUE"])
                }
                # binary - dissimilarity - Size difference: binSzD - SIZE
                else if (mthNme == "binSzD") {
                    resMtx[i, j] = (mtcVec[2] - mtcVec[3]) ^ 2 / (nrow(dtaMtx) ^ 2)
                }
                # binary - dissimilarity - Variance: binVar - VARIANCE
                else if (mthNme == "binVar") {
                    resMtx[i, j] = (mtcVec[2] + mtcVec[3]) / (4 * nrow(dtaMtx))
                }
                # binary - similarity - Yule's Q: binYlQ - Q
                else if (mthNme == "binYlQ") {
                    resMtx[i, j] = (mtcVec[1] * mtcVec[4] - mtcVec[2] * mtcVec[3]) / (mtcVec[1] * mtcVec[4] + mtcVec[2] * mtcVec[3])
                }
                # binary - similarity - Yule's Y: binYlY - Y
                else if (mthNme == "binYlY") {
                    resMtx[i, j] = (sqrt(mtcVec[1] * mtcVec[4]) - sqrt(mtcVec[2] * mtcVec[3])) / (sqrt(mtcVec[1] * mtcVec[4]) + sqrt(mtcVec[2] * mtcVec[3]))
                }
#               PLACEHOLDER FOR FUTURE IMPLEMENTATIONS
#               else if (mthNme == "bin") {
#               }
            }
        }

        # =============================================================================================================
        # transpose and add the matrix (only the bottom triangle is calculated, th upper is "mirrored")
        # =============================================================================================================
        resMtx = resMtx + t(resMtx)
        # handle the main diagonal
        if      (mthNme == "binEuc" || mthNme == "binLnW" || mthNme == "binPtD" || mthNme == "binShp" || mthNme == "binSqE" || mthNme == "binSzD" || mthNme == "binVar")
            diag(resMtx) = 0
        else if (mthNme == "intCos" || mthNme == "cntChi" || mthNme == "cntChi" || mthNme == "binDic" || mthNme == "binJcc" || mthNme == "binHmm" || mthNme == "binKc2" || 
                 mthNme == "binLmb" || mthNme == "binOch" || mthNme == "binPh4" || mthNme == "binRnT" || mthNme == "binSmM" || mthNme == "binSk1" || mthNme == "binSk2" ||
                 mthNme == "binSk4" || mthNme == "binSk5" || mthNme == "binYlY" || mthNme == "binYlQ")
            diag(resMtx) = 1
        else if (mthNme == "binKc1" || mthNme == "binSk3")
            diag(resMtx) = NA
        else if (mthNme == "binAnD" || mthNme == "binDsp" || mthNme == "binRnR")
            diag(resMtx) = diag(resMtx) / 2
    
    }
    # =================================================================================================================
    # end: own implementations
    # =================================================================================================================

    # =================================================================================================================
    # return matrix with results
    # =================================================================================================================
    return(resMtx)
}

# =====================================================================================================================
# Transforming data before calculating the proximity measures
# =====================================================================================================================
xfmDta <- function(dtaMtx, xfmMth, xfmDir) {
    xfmDim = ifelse(xfmDir == "xfmVar", 2, ifelse(xfmDir == "xfmSbj", 1, NA))

    # z-scores - Z - correct
    if      (xfmMth == "xfmZsc")
        xfmMtx = sweep(sweep(dtaMtx, xfmDim, as.vector(apply(dtaMtx, xfmDim, mean)),  "-"), xfmDim, as.vector(apply(dtaMtx, xfmDim, sd)),          "/")
    # range -1 to 1 - RANGE - over subjects correct, over variables possibly wrong in SPSS
    else if (xfmMth == "xfmRNP")
        xfmMtx = sweep(dtaMtx, xfmDim, as.vector(diff(apply(dtaMtx, xfmDim, range))), "/")
    # range 0 to 1 - RESCALE - over subjects correct, over variables possibly wrong in SPSS
    else if (xfmMth == "xfmRZP")
        xfmMtx = sweep(sweep(dtaMtx, xfmDim, as.vector(apply(dtaMtx, xfmDim, min)),   "-"), xfmDim, as.vector(diff(apply(dtaMtx, xfmDim, range))), "/")
    # maximum magnitude of 1 - MAX - correct
    else if (xfmMth == "xfmMag")
        xfmMtx = sweep(dtaMtx, xfmDim, as.vector(apply(dtaMtx, xfmDim, max)),  "/")
    # mean of 1 - MEAN - correct
    else if (xfmMth == "xfmAvr")
        xfmMtx = sweep(dtaMtx, xfmDim, as.vector(apply(dtaMtx, xfmDim, mean)), "/")
    # standard deviation of 1 - SD - correct
    else if (xfmMth == "xfmStd")
        xfmMtx = sweep(dtaMtx, xfmDim, as.vector(apply(dtaMtx, xfmDim, sd)),   "/")

    return(xfmMtx)
}

# =====================================================================================================================
# Transforming the result mastix after calculating the proximity measures
# =====================================================================================================================
xfmRes <- function(resMtx, blnXfR) {
    if (blnXfR[1])
        resMtx = abs(resMtx)
    if (blnXfR[2])
        resMtx[row(resMtx) != col(resMtx)] = -resMtx[row(resMtx) != col(resMtx)]
    if (blnXfR[3])
        resMtx[row(resMtx) != col(resMtx)] = (resMtx[row(resMtx) != col(resMtx)] - min(resMtx[row(resMtx) != col(resMtx)])) / diff(range(resMtx[row(resMtx) != col(resMtx)]))

    return(resMtx)
}

# =====================================================================================================================
# Transforming data before calculating the proximity measures
# =====================================================================================================================
nmePxm <- function(mthNme) {
    # measures for interval data
    if      (mthNme == "intBlk")
        resNme = "Block"
    else if (mthNme == "intChb")
        resNme = "Chebychev"
    else if (mthNme == "intCst")
        resNme = "Customized, based upon Minkowski with Power: _IP_, Root: _IR_"
    else if (mthNme == "intCos")
        resNme = "Cosine"
    else if (mthNme == "intCrr")
        resNme = "Pearson correlation"
    else if (mthNme == "intEuc")
        resNme = "Euclidian distance"
    else if (mthNme == "intMnk")
        resNme = "Minkowski (Power: _IP_)"
    else if (mthNme == "intSqE")
        resNme = "Squared Euclidian distance"
    # count / frequency measures
    else if (mthNme == "cntChi")
        resNme = "Chi-squared measure"
    else if (mthNme == "cntPhi")
        resNme = "Phi-squared measure"
    # binary measures
    else if (mthNme == "binAnD")
        resNme = "Anderberg's D; present: _BP_, absent: _BA_"
    else if (mthNme == "binDic")
        resNme = "Dice; present: _BP_, absent: _BA_"
    else if (mthNme == "binDsp")
        resNme = "Dispersion; present: _BP_, absent: _BA_"
    else if (mthNme == "binEuc")
        resNme = "(Binary) Euclidian distance; present: _BP_, absent: _BA_"
    else if (mthNme == "binHmn")
        resNme = "Hamann; present: _BP_, absent: _BA_"
    else if (mthNme == "binJcc")
        resNme = "Jaccard; present: _BP_, absent: _BA_"
    else if (mthNme == "binKc1")
        resNme = "Kulczynski 1; present: _BP_, absent: _BA_"
    else if (mthNme == "binKc2")
        resNme = "Kulczynski 2; present: _BP_, absent: _BA_"
    else if (mthNme == "binLmb")
        resNme = "Lambda; present: _BP_, absent: _BA_"
    else if (mthNme == "binLnW")
        resNme = "Lance and Williams; present: _BP_, absent: _BA_"
    else if (mthNme == "binOch")
        resNme = "Ochiai; present: _BP_, absent: _BA_"
    else if (mthNme == "binPh4")
        resNme = "Phi 4-point correlation; present: _BP_, absent: _BA_"
    else if (mthNme == "binPtD")
        resNme = "Pattern difference; present: _BP_, absent: _BA_"
    else if (mthNme == "binRnR")
        resNme = "Russel and Rao; present: _BP_, absent: _BA_"
    else if (mthNme == "binRnT")
        resNme = "Rogers and Tanimoto; present: _BP_, absent: _BA_"
    else if (mthNme == "binShp")
        resNme = "Shape; present: _BP_, absent: _BA_"
    else if (mthNme == "binSk1")
        resNme = "Sokal and Sneath 1; present: _BP_, absent: _BA_"
    else if (mthNme == "binSk2")
        resNme = "Sokal and Sneath 2; present: _BP_, absent: _BA_"
    else if (mthNme == "binSk3")
        resNme = "Sokal and Sneath 3; present: _BP_, absent: _BA_"
    else if (mthNme == "binSk4")
        resNme = "Sokal and Sneath 4; present: _BP_, absent: _BA_"
    else if (mthNme == "binSk5")
        resNme = "Sokal and Sneath 5; present: _BP_, absent: _BA_"
    else if (mthNme == "binSmM")
        resNme = "Simple matching; present: _BP_, absent: _BA_"
    else if (mthNme == "binSqE")
        resNme = "(Binary) squared Euclidian distance; present: _BP_, absent: _BA_"
    else if (mthNme == "binSzD")
        resNme = "Size difference; present: _BP_, absent: _BA_"
    else if (mthNme == "binVar")
        resNme = "(Binary) variance; present: _BP_, absent: _BA_"
    else if (mthNme == "binYlQ")
        resNme = "Yule's Q; present: _BP_, absent: _BA_"
    else if (mthNme == "binYlY")
        resNme = "Yule's Y; present: _BP_, absent: _BA_"
#   else if (mthNme == "")
#       resNme = ""
    else
        resNme = ""

    return(resNme)
}

spsPxm <- function(mthNme) {
    # measures for interval data
    if      (mthNme == "intBlk")
        spssMt = "BLOCK"
    else if (mthNme == "intChb")
        spssMt = "CHEBYCHEV"
    else if (mthNme == "intCst")
        spssMt = "POWER(_IP_, _IR_)"
    else if (mthNme == "intCos")
        spssMt = "COSINE"
    else if (mthNme == "intCrr")
        spssMt = "CORRELATION"
    else if (mthNme == "intEuc")
        spssMt = "EUCLID"
    else if (mthNme == "intMnk")
        spssMt = "MINKOWSKI(_IP_)"
    else if (mthNme == "intSqE")
        spssMt = "SEUCLID"
    # count / frequency measures
    else if (mthNme == "cntChi")
        spssMt = "CHISQ"
    else if (mthNme == "cntPhi")
        spssMt = "PH2"
    # binary measures
    else if (mthNme == "binAnD")
        spssMt = "D(_BP_, _BA_)"
    else if (mthNme == "binDic")
        spssMt = "DICE(_BP_, _BA_)"
    else if (mthNme == "binDsp")
        spssMt = "DISPER(_BP_, _BA_)"
    else if (mthNme == "binEuc")
        spssMt = "BEUCLID(_BP_, _BA_)"
    else if (mthNme == "binHmn")
        spssMt = "HAMANN(_BP_, _BA_)"
    else if (mthNme == "binJcc")
        spssMt = "JACCARD(_BP_, _BA_)"
    else if (mthNme == "binKc1")
        spssMt = "K1(_BP_, _BA_)"
    else if (mthNme == "binKc2")
        spssMt = "K2(_BP_, _BA_)"
    else if (mthNme == "binLmb")
        spssMt = "LAMBDA(_BP_, _BA_)"
    else if (mthNme == "binLnW")
        spssMt = "BLWMN(_BP_, _BA_)"
    else if (mthNme == "binOch")
        spssMt = "OCHIAI(_BP_, _BA_)"
    else if (mthNme == "binPh4")
        spssMt = "PHI(_BP_, _BA_)"
    else if (mthNme == "binPtD")
        spssMt = "PATTERN(_BP_, _BA_)"
    else if (mthNme == "binRnR")
        spssMt = "RR(_BP_, _BA_)"
    else if (mthNme == "binRnT")
        spssMt = "RT(_BP_, _BA_)"
    else if (mthNme == "binShp")
        spssMt = "BSHAPE(_BP_, _BA_)"
    else if (mthNme == "binSk1")
        spssMt = "SS1(_BP_, _BA_)"
    else if (mthNme == "binSk2")
        spssMt = "SS2(_BP_, _BA_)"
    else if (mthNme == "binSk3")
        spssMt = "SS3(_BP_, _BA_)"
    else if (mthNme == "binSk4")
        spssMt = "SS4(_BP_, _BA_)"
    else if (mthNme == "binSk5")
        spssMt = "SS5(_BP_, _BA_)"
    else if (mthNme == "binSmM")
        spssMt = "SM(_BP_, _BA_)"
    else if (mthNme == "binSqE")
        spssMt = "BSEUCLID(_BP_, _BA_)"
    else if (mthNme == "binSzD")
        spssMt = "SIZE(_BP_, _BA_)"
    else if (mthNme == "binVar")
        spssMt = "VARIANCE(_BP_, _BA_)"
    else if (mthNme == "binYlQ")
        spssMt = "Q(_BP_, _BA_)"
    else if (mthNme == "binYlY")
        spssMt = "Y(_BP_, _BA_)"
#   else if (mthNme == "")
#       spssMt = ""
    else
        spssMt = ""

    return(spssMt)
}
